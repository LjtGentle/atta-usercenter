// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.6.1
// source: api/usercenter/v1/login.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// LoginClient is the client API for Login service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LoginClient interface {
	// 普通用户登录
	OrdinaryLogin(ctx context.Context, in *OrdinaryLoginRequest, opts ...grpc.CallOption) (*OrdinaryLoginReply, error)
	// 管理员登录
	AdminLogin(ctx context.Context, in *AdminLoginRequest, opts ...grpc.CallOption) (*AdminLoginReply, error)
}

type loginClient struct {
	cc grpc.ClientConnInterface
}

func NewLoginClient(cc grpc.ClientConnInterface) LoginClient {
	return &loginClient{cc}
}

func (c *loginClient) OrdinaryLogin(ctx context.Context, in *OrdinaryLoginRequest, opts ...grpc.CallOption) (*OrdinaryLoginReply, error) {
	out := new(OrdinaryLoginReply)
	err := c.cc.Invoke(ctx, "/v1.Login/OrdinaryLogin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loginClient) AdminLogin(ctx context.Context, in *AdminLoginRequest, opts ...grpc.CallOption) (*AdminLoginReply, error) {
	out := new(AdminLoginReply)
	err := c.cc.Invoke(ctx, "/v1.Login/AdminLogin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LoginServer is the server API for Login service.
// All implementations must embed UnimplementedLoginServer
// for forward compatibility
type LoginServer interface {
	// 普通用户登录
	OrdinaryLogin(context.Context, *OrdinaryLoginRequest) (*OrdinaryLoginReply, error)
	// 管理员登录
	AdminLogin(context.Context, *AdminLoginRequest) (*AdminLoginReply, error)
	mustEmbedUnimplementedLoginServer()
}

// UnimplementedLoginServer must be embedded to have forward compatible implementations.
type UnimplementedLoginServer struct {
}

func (UnimplementedLoginServer) OrdinaryLogin(context.Context, *OrdinaryLoginRequest) (*OrdinaryLoginReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrdinaryLogin not implemented")
}
func (UnimplementedLoginServer) AdminLogin(context.Context, *AdminLoginRequest) (*AdminLoginReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AdminLogin not implemented")
}
func (UnimplementedLoginServer) mustEmbedUnimplementedLoginServer() {}

// UnsafeLoginServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LoginServer will
// result in compilation errors.
type UnsafeLoginServer interface {
	mustEmbedUnimplementedLoginServer()
}

func RegisterLoginServer(s grpc.ServiceRegistrar, srv LoginServer) {
	s.RegisterService(&Login_ServiceDesc, srv)
}

func _Login_OrdinaryLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrdinaryLoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoginServer).OrdinaryLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Login/OrdinaryLogin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoginServer).OrdinaryLogin(ctx, req.(*OrdinaryLoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Login_AdminLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AdminLoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoginServer).AdminLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Login/AdminLogin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoginServer).AdminLogin(ctx, req.(*AdminLoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Login_ServiceDesc is the grpc.ServiceDesc for Login service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Login_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "v1.Login",
	HandlerType: (*LoginServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OrdinaryLogin",
			Handler:    _Login_OrdinaryLogin_Handler,
		},
		{
			MethodName: "AdminLogin",
			Handler:    _Login_AdminLogin_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/usercenter/v1/login.proto",
}

// RegisterClient is the client API for Register service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegisterClient interface {
	// 注册普通用户
	OrdinaryRegister(ctx context.Context, in *OrdinaryRegisterRequest, opts ...grpc.CallOption) (*OrdinaryRegisterReply, error)
}

type registerClient struct {
	cc grpc.ClientConnInterface
}

func NewRegisterClient(cc grpc.ClientConnInterface) RegisterClient {
	return &registerClient{cc}
}

func (c *registerClient) OrdinaryRegister(ctx context.Context, in *OrdinaryRegisterRequest, opts ...grpc.CallOption) (*OrdinaryRegisterReply, error) {
	out := new(OrdinaryRegisterReply)
	err := c.cc.Invoke(ctx, "/v1.Register/OrdinaryRegister", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegisterServer is the server API for Register service.
// All implementations must embed UnimplementedRegisterServer
// for forward compatibility
type RegisterServer interface {
	// 注册普通用户
	OrdinaryRegister(context.Context, *OrdinaryRegisterRequest) (*OrdinaryRegisterReply, error)
	mustEmbedUnimplementedRegisterServer()
}

// UnimplementedRegisterServer must be embedded to have forward compatible implementations.
type UnimplementedRegisterServer struct {
}

func (UnimplementedRegisterServer) OrdinaryRegister(context.Context, *OrdinaryRegisterRequest) (*OrdinaryRegisterReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrdinaryRegister not implemented")
}
func (UnimplementedRegisterServer) mustEmbedUnimplementedRegisterServer() {}

// UnsafeRegisterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegisterServer will
// result in compilation errors.
type UnsafeRegisterServer interface {
	mustEmbedUnimplementedRegisterServer()
}

func RegisterRegisterServer(s grpc.ServiceRegistrar, srv RegisterServer) {
	s.RegisterService(&Register_ServiceDesc, srv)
}

func _Register_OrdinaryRegister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrdinaryRegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegisterServer).OrdinaryRegister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Register/OrdinaryRegister",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegisterServer).OrdinaryRegister(ctx, req.(*OrdinaryRegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Register_ServiceDesc is the grpc.ServiceDesc for Register service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Register_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "v1.Register",
	HandlerType: (*RegisterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OrdinaryRegister",
			Handler:    _Register_OrdinaryRegister_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/usercenter/v1/login.proto",
}

// ApplyClient is the client API for Apply service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ApplyClient interface {
	// 实名验证申请
	RealNameVerification(ctx context.Context, in *RealNameVerificationRequest, opts ...grpc.CallOption) (*RealNameVerificationReply, error)
	// 成为陪玩申请
	BecomeGameCoach(ctx context.Context, in *BecomeGameCoachRequest, opts ...grpc.CallOption) (*BecomeGameCoachReply, error)
}

type applyClient struct {
	cc grpc.ClientConnInterface
}

func NewApplyClient(cc grpc.ClientConnInterface) ApplyClient {
	return &applyClient{cc}
}

func (c *applyClient) RealNameVerification(ctx context.Context, in *RealNameVerificationRequest, opts ...grpc.CallOption) (*RealNameVerificationReply, error) {
	out := new(RealNameVerificationReply)
	err := c.cc.Invoke(ctx, "/v1.Apply/RealNameVerification", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *applyClient) BecomeGameCoach(ctx context.Context, in *BecomeGameCoachRequest, opts ...grpc.CallOption) (*BecomeGameCoachReply, error) {
	out := new(BecomeGameCoachReply)
	err := c.cc.Invoke(ctx, "/v1.Apply/BecomeGameCoach", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ApplyServer is the server API for Apply service.
// All implementations must embed UnimplementedApplyServer
// for forward compatibility
type ApplyServer interface {
	// 实名验证申请
	RealNameVerification(context.Context, *RealNameVerificationRequest) (*RealNameVerificationReply, error)
	// 成为陪玩申请
	BecomeGameCoach(context.Context, *BecomeGameCoachRequest) (*BecomeGameCoachReply, error)
	mustEmbedUnimplementedApplyServer()
}

// UnimplementedApplyServer must be embedded to have forward compatible implementations.
type UnimplementedApplyServer struct {
}

func (UnimplementedApplyServer) RealNameVerification(context.Context, *RealNameVerificationRequest) (*RealNameVerificationReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RealNameVerification not implemented")
}
func (UnimplementedApplyServer) BecomeGameCoach(context.Context, *BecomeGameCoachRequest) (*BecomeGameCoachReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BecomeGameCoach not implemented")
}
func (UnimplementedApplyServer) mustEmbedUnimplementedApplyServer() {}

// UnsafeApplyServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ApplyServer will
// result in compilation errors.
type UnsafeApplyServer interface {
	mustEmbedUnimplementedApplyServer()
}

func RegisterApplyServer(s grpc.ServiceRegistrar, srv ApplyServer) {
	s.RegisterService(&Apply_ServiceDesc, srv)
}

func _Apply_RealNameVerification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RealNameVerificationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplyServer).RealNameVerification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Apply/RealNameVerification",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplyServer).RealNameVerification(ctx, req.(*RealNameVerificationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Apply_BecomeGameCoach_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BecomeGameCoachRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplyServer).BecomeGameCoach(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Apply/BecomeGameCoach",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplyServer).BecomeGameCoach(ctx, req.(*BecomeGameCoachRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Apply_ServiceDesc is the grpc.ServiceDesc for Apply service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Apply_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "v1.Apply",
	HandlerType: (*ApplyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RealNameVerification",
			Handler:    _Apply_RealNameVerification_Handler,
		},
		{
			MethodName: "BecomeGameCoach",
			Handler:    _Apply_BecomeGameCoach_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/usercenter/v1/login.proto",
}

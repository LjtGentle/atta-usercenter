// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// protoc-gen-go-http v2.1.4

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

type LoginHTTPServer interface {
	AdminLogin(context.Context, *AdminLoginRequest) (*AdminLoginReply, error)
	OrdinaryLogin(context.Context, *OrdinaryLoginRequest) (*OrdinaryLoginReply, error)
}

func RegisterLoginHTTPServer(s *http.Server, srv LoginHTTPServer) {
	r := s.Route("/")
	r.GET("/userCenter/ordinaryLogin", _Login_OrdinaryLogin0_HTTP_Handler(srv))
	r.GET("/userCenter/adminLogin", _Login_AdminLogin0_HTTP_Handler(srv))
}

func _Login_OrdinaryLogin0_HTTP_Handler(srv LoginHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in OrdinaryLoginRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/v1.Login/OrdinaryLogin")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.OrdinaryLogin(ctx, req.(*OrdinaryLoginRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*OrdinaryLoginReply)
		return ctx.Result(200, reply)
	}
}

func _Login_AdminLogin0_HTTP_Handler(srv LoginHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in AdminLoginRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/v1.Login/AdminLogin")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.AdminLogin(ctx, req.(*AdminLoginRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*AdminLoginReply)
		return ctx.Result(200, reply)
	}
}

type LoginHTTPClient interface {
	AdminLogin(ctx context.Context, req *AdminLoginRequest, opts ...http.CallOption) (rsp *AdminLoginReply, err error)
	OrdinaryLogin(ctx context.Context, req *OrdinaryLoginRequest, opts ...http.CallOption) (rsp *OrdinaryLoginReply, err error)
}

type LoginHTTPClientImpl struct {
	cc *http.Client
}

func NewLoginHTTPClient(client *http.Client) LoginHTTPClient {
	return &LoginHTTPClientImpl{client}
}

func (c *LoginHTTPClientImpl) AdminLogin(ctx context.Context, in *AdminLoginRequest, opts ...http.CallOption) (*AdminLoginReply, error) {
	var out AdminLoginReply
	pattern := "/userCenter/adminLogin"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/v1.Login/AdminLogin"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *LoginHTTPClientImpl) OrdinaryLogin(ctx context.Context, in *OrdinaryLoginRequest, opts ...http.CallOption) (*OrdinaryLoginReply, error) {
	var out OrdinaryLoginReply
	pattern := "/userCenter/ordinaryLogin"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/v1.Login/OrdinaryLogin"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

type RegisterHTTPServer interface {
	OrdinaryRegister(context.Context, *OrdinaryRegisterRequest) (*OrdinaryRegisterReply, error)
}

func RegisterRegisterHTTPServer(s *http.Server, srv RegisterHTTPServer) {
	r := s.Route("/")
	r.POST("/userCenter/ordinaryRegister", _Register_OrdinaryRegister0_HTTP_Handler(srv))
}

func _Register_OrdinaryRegister0_HTTP_Handler(srv RegisterHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in OrdinaryRegisterRequest
		if err := ctx.Bind(&in.Message); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/v1.Register/OrdinaryRegister")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.OrdinaryRegister(ctx, req.(*OrdinaryRegisterRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*OrdinaryRegisterReply)
		return ctx.Result(200, reply)
	}
}

type RegisterHTTPClient interface {
	OrdinaryRegister(ctx context.Context, req *OrdinaryRegisterRequest, opts ...http.CallOption) (rsp *OrdinaryRegisterReply, err error)
}

type RegisterHTTPClientImpl struct {
	cc *http.Client
}

func NewRegisterHTTPClient(client *http.Client) RegisterHTTPClient {
	return &RegisterHTTPClientImpl{client}
}

func (c *RegisterHTTPClientImpl) OrdinaryRegister(ctx context.Context, in *OrdinaryRegisterRequest, opts ...http.CallOption) (*OrdinaryRegisterReply, error) {
	var out OrdinaryRegisterReply
	pattern := "/userCenter/ordinaryRegister"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/v1.Register/OrdinaryRegister"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in.Message, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

type ApplyHTTPServer interface {
	BecomeGameCoach(context.Context, *BecomeGameCoachRequest) (*BecomeGameCoachReply, error)
	RealNameVerification(context.Context, *RealNameVerificationRequest) (*RealNameVerificationReply, error)
}

func RegisterApplyHTTPServer(s *http.Server, srv ApplyHTTPServer) {
	r := s.Route("/")
	r.POST("/userCenter/RealNameVerification", _Apply_RealNameVerification0_HTTP_Handler(srv))
	r.POST("/userCenter/BecomeGameCoach", _Apply_BecomeGameCoach0_HTTP_Handler(srv))
}

func _Apply_RealNameVerification0_HTTP_Handler(srv ApplyHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in RealNameVerificationRequest
		if err := ctx.Bind(&in.Message); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/v1.Apply/RealNameVerification")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.RealNameVerification(ctx, req.(*RealNameVerificationRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*RealNameVerificationReply)
		return ctx.Result(200, reply)
	}
}

func _Apply_BecomeGameCoach0_HTTP_Handler(srv ApplyHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in BecomeGameCoachRequest
		if err := ctx.Bind(&in.Message); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/v1.Apply/BecomeGameCoach")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.BecomeGameCoach(ctx, req.(*BecomeGameCoachRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*BecomeGameCoachReply)
		return ctx.Result(200, reply)
	}
}

type ApplyHTTPClient interface {
	BecomeGameCoach(ctx context.Context, req *BecomeGameCoachRequest, opts ...http.CallOption) (rsp *BecomeGameCoachReply, err error)
	RealNameVerification(ctx context.Context, req *RealNameVerificationRequest, opts ...http.CallOption) (rsp *RealNameVerificationReply, err error)
}

type ApplyHTTPClientImpl struct {
	cc *http.Client
}

func NewApplyHTTPClient(client *http.Client) ApplyHTTPClient {
	return &ApplyHTTPClientImpl{client}
}

func (c *ApplyHTTPClientImpl) BecomeGameCoach(ctx context.Context, in *BecomeGameCoachRequest, opts ...http.CallOption) (*BecomeGameCoachReply, error) {
	var out BecomeGameCoachReply
	pattern := "/userCenter/BecomeGameCoach"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/v1.Apply/BecomeGameCoach"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in.Message, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ApplyHTTPClientImpl) RealNameVerification(ctx context.Context, in *RealNameVerificationRequest, opts ...http.CallOption) (*RealNameVerificationReply, error) {
	var out RealNameVerificationReply
	pattern := "/userCenter/RealNameVerification"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/v1.Apply/RealNameVerification"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in.Message, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
